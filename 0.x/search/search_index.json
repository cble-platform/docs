{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>This documentation site is still heavily under construction. Please come back later for full documentation.</p> <p>The Cloud-Based Lab Emulator (or CBLE for short) is designed to be a fully-automated self-service virtual lab environment that is cloud provider agnostic. This means whatever your resources, CBLE can scale to be the solution you need.</p> <p>Get Started </p>"},{"location":"#project-inspiration","title":"Project Inspiration","text":"<p>This project was proposed as an Independent Study at Rochester Institute of Technology as a part of my (Bradley Harker) Cybersecurity MS degree program in the Fall 2023 semester. The original project proposal is here:</p> Proposal <p>The goal of this independent study is to develop a fully-automated self-service virtual lab environment that aims to be both scalable and flexible to fit any form of deployment as well as learn about requirements engineering, project planning, and project design throughout the process. The platform will be provider agnostic, allowing it to conform to any public or private cloud provider to host the underlying virtual lab machines. It will support both legacy and modern work-flows for lab development, speeding up the process of evolving course content. The intention is to expand this into production to offer a replacement for the current Remote Laboratory Emulation System (RLES) and integrate in the Computing Security/Cybersecurity future curriculum. The project will include proofing the ease of migration by migrating existing course lab content to the new platform. The requirements engineering will be performed by interviewing multiple stakeholders involved in the project such as: RIT Faculty (ITS/Teaching Staff), Students, and External Academic Institution Faculty. Doing this will help general the project requirements needed to satisfy all potential stakeholders in the project. Project design will be performed surrounding the requirements identified. A report of this process will be written and presented to describe both the findings of the interviews and the resulting design extrapolated from the findings. No current course in the CSEC curriculum offers this kind of opportunity to develop a product (the platform) in collaboration with a client (RIT) and teach the project design and project management progress.</p>"},{"location":"getting-started/quick-start/","title":"Getting Started","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>This is NOT recommended for use in a production environment at the current state. Please check back later for production-ready deployment.</p>"},{"location":"getting-started/quick-start/#quick-start","title":"Quick Start","text":"<p>To get started, clone the deployment repository:</p> <pre><code>git clone --recursive https://github.com/cble-platform/deploy cble-deploy\n</code></pre> <p>Move into the deploy directory and duplicate the main config example file:</p> <pre><code>cd cble-deploy\ncp config.example.yaml config.local.yaml\n</code></pre> <p>You can now modify the <code>config.local.yaml</code> file with your specific configuration (see Config File Reference for more).</p> <p>Place your production domain at the top of the <code>Caddyfile</code>:</p> Caddyfile<pre><code>&lt;your domain here&gt; {\n    # ...\n}\n</code></pre> <p>You should now be able to run CBLE:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"getting-started/blueprints/concepts/","title":"Concepts","text":"<p>There are a few key concepts to understand when working with CBLE blueprints:</p>"},{"location":"getting-started/blueprints/concepts/#resources","title":"Resources","text":"<p>A resource represents something which would be deployed in the cloud. This might be a server, a database, a load balancer, a router, anything you can deploy in the cloud (which CBLE supports; see Providers).</p> <p>Let's use this resource as an example:</p> Example resource<pre><code>host1:\n  resource: openstack.v1.host\n  config:\n    hostname: host1\n    image: UbuntuJammy2204\n    flavor: medium\n    disk_size: 10\n    networks:\n      network1:\n        dhcp: false\n        ip: 10.10.0.1\n  depends_on:\n    - router1\n</code></pre> <p>There is a lot to unpack here, but let's unpack line-by-line:</p> <ol> <li><code>host1:</code> - This represents a unique key which can be used to reference this resource elsewhere in the blueprint</li> <li><code>resource: openstack.v1.host</code> - Defines the type of resources this reference represents (in this case a host on OpenStack)</li> <li><code>config:</code> - This entire block is going to be unique to each provider used. Values here are used by the provider to    deploy/configure the intended resource</li> <li><code>depends_on</code> - This is a list of other resource references (like line 1) on which this resource depends. This resource    will not be deployed until all <code>depends_on</code> resources are successful. This resource will be destroyed before any <code>depends_on</code>    resources are destroyed</li> </ol> <p>For more information on the resource configs, please refer to the provider documentation.</p>"},{"location":"getting-started/blueprints/overview/","title":"Blueprints","text":"<p>CBLE Blueprints are a custom YAML-based configuration language inspired by Terraform and Docker Compose v3 syntax.</p> <p>Here is what a basic blueprint looks like:</p> openstack-example.yaml<pre><code>version: \"1.0\" # (1)!\n\nhost1:\n  resource: openstack.v1.host # (2)!\n  config: # (3)!\n    hostname: host1\n    image: UbuntuJammy2204\n    flavor: medium\n    disk_size: 10\n    networks:\n      network1:\n        dhcp: false\n        ip: 10.10.0.1\n  depends_on: # (4)!\n    - router1\n\nhost2:\n  resource: openstack.v1.host\n  config:\n    hostname: host2\n    image: UbuntuJammy2204-Desktop\n    flavor: medium\n    disk_size: 25\n    networks:\n      network1:\n        dhcp: true\n  depends_on:\n    - host1\n    - router1\n\nnetwork1:\n  resource: openstack.v1.network\n  config:\n    subnet: 10.10.0.0/24\n    gateway: 10.10.0.254\n    dhcp:\n      - start: 10.10.0.10\n        end: 10.10.0.100\n\nrouter1:\n  resource: openstack.v1.router\n  config:\n    external_network: MAIN-NAT\n    networks:\n      network1:\n        dhcp: false\n        ip: 10.10.0.254\n</code></pre> <ol> <li>This version refers to the version of blueprint syntax. This may change over time.</li> <li>This is called a resource type. Resource types are how CBLE knows what type of resource to deploy for this object.</li> <li>This is the resource config. A config is unique to the type of provider you're using.</li> <li><code>depends_on</code> is similar to Docker Compose v3. This allows us to wait on other objects to deploy before we    deploy this object (and destroy this object before we destroy the parents). Providers should provide inherent    dependencies based on resource types.</li> </ol>"},{"location":"getting-started/providers/overview/","title":"Providers","text":"<p>Providers in CBLE are the link between CBLE Blueprints and the \"real world\" (aka. the cloud). CBLE Providers are designed to be standalone binaries which use gRPC for inter-process communication (IPC). This IPC is done via a local unix socket and can optionally be secure with TLS (not currently supported).</p> <p>Note</p> <p>As of now, the only officially supported language for providers is Go. This will be expanded in the  future with the addition of provider metadata files. You can track the progress of that here.</p>"},{"location":"getting-started/providers/overview/#supported-providers","title":"Supported Providers","text":"<p>A list of official providers is here:</p> <ul> <li>cble-platform/provider-openstack</li> </ul> <p>You can also provider your own provider if you'd like. See Writing a Provider section for more information.</p>"},{"location":"getting-started/providers/overview/#behind-the-scenes","title":"Behind the Scenes","text":""},{"location":"getting-started/providers/overview/#design","title":"Design","text":"<p>The CBLE server is designed to connect to many different providers at once. In doing so, a main go routine monitoring all incoming registration requests wait for registrations. Once one is received, a new go routine is spawned with a client to connect to that provider's gRPC server.</p> <p> </p> CBLE Provider gRPC Design"},{"location":"getting-started/providers/overview/#loading-providers","title":"Loading Providers","text":"<p>To load providers into CBLE, you must provide a Git remote, tag (version), and name for the provider. This will be used to fetch and compile the provider into the provider cache.</p> <p>The basic flow of loading CBLE providers is as follows:</p> <pre><code>flowchart\n  init[\"Initialize Provider\"]\n  init-- Exists in provider cache --&gt;checkGitTag\n  init-- Doesn't exist in provider cache --&gt;clone\n  checkGitTag[\"Inspect checked out git tag (version)&lt;br /&gt;\"]\n  checkGitTag-- Doesn't match expected version --&gt;checkoutVersion\n  checkGitTag-- Matches expected version --&gt;compileProvider\n  clone[\"Clone from git\"]\n  clone--&gt;checkoutVersion\n  checkoutVersion[\"Checkout requested tag (version)\"]\n  checkoutVersion--&gt;compileProvider\n  compileProvider[\"Compile provider code&lt;br /&gt;(e.g. cd /path/to/provider &amp;&amp; go build .)\"]\n  compileProvider--&gt;runProvider\n  runProvider[\"Run provider binary with provider [id]&lt;br /&gt;(e.g. ./provider xxxxxx-xxxxxx-xxxxxx-xxxxxx)\"]\n  linkStyle 0,3 color:green;\n  linkStyle 1,2 color:red;</code></pre> <p>This flow is triggered on startup for CBLE for any pre-existing providers in the database and can be triggered manually by calling the <code>loadProvider</code> GraphQL mutation.</p>"},{"location":"getting-started/providers/overview/#registration","title":"Registration","text":"<p>Providers, on startup, will register themselves with the CBLE server in order to establish a peristent gRPC connection. This process also prevents rogue providers from starting up without knowing the provider ID ahead of time.</p> <p>After an initial handshake process, the provider will start up its own gRPC server which can be used to provider commands to the provider. This process is as follows:</p> <pre><code>sequenceDiagram\n  autonumber\n  participant C as CBLE gRPC Server\n  participant P as Provider gRPC Client\n\n  note over P: Startup\n\n  critical Checks protocol versions\n    P-&gt;&gt;C: Handshake(client_version)\n    C-&gt;&gt;P: HandshakeReply(server_version)\n  option Versions don't match\n    note over C,P: Connection Terminated\n  end\n\n  P-&gt;&gt;C: RegisterProvider(id, name, version, features)\n  note over C: Store provider [id], name, and version\n  C-&gt;&gt;P: RegisterReply(status, socket_id)\n  note over P: Start provider gRPC server\n  note over C: Connect to provider on&lt;br /&gt;/tmp/cble-provider-[id].sock</code></pre>"},{"location":"getting-started/providers/overview/#commands","title":"Commands","text":"<p>As of now, there are a few pre-defined commands the CBLE server can issue to providers. These are <code>Configure</code>, <code>Deploy</code>, and <code>Destroy</code>.</p> <p>These commands are issued via the gRPC provider client for the specified provider. Very rarely will you have to directly interact with these as they are abstracted by GraphQL mutations within the CBLE API.</p>"},{"location":"getting-started/providers/overview/#configure","title":"<code>Configure</code>","text":"<p>This command is used to reload the configuration of a provider without having to restart the provider itself. Configurations are stored within the CBLE database for portability and because of this, this command is executed on each startup of the providers.</p>"},{"location":"getting-started/providers/overview/#deploy","title":"<code>Deploy</code>","text":"<p>This command deploys a given blueprint. The deployment state and any variables stored are returned to CBLE as maps.</p> <p>Note</p> <p>This command will eventually return a gRPC stream in order to provider real-time feedback on deployment progress. You can track the progress of that here.</p>"},{"location":"getting-started/providers/overview/#destroy","title":"<code>Destroy</code>","text":"<p>This command destroys a given deployment. The deployment state and any variables stored are returned to CBLE as maps.</p> <p>Note</p> <p>This command will eventually return a gRPC stream in order to provider real-time feedback on deployment progress. You can track the progress of that here.</p>"},{"location":"getting-started/providers/overview/#unregistration","title":"Unregistration","text":"<p>Unregistration occurs when a provider is ready to shutdown and would like to do so gracefully. Without this, the gRPC clients created by the CBLE server would panic. To accomplish this, the provider will send an unregister request to the CBLE server (using it's gRPC client) and then will gracefully shutdown it's gRPC server, disconnecting all clients in the process.</p> <pre><code>sequenceDiagram\n  autonumber\n  participant C as CBLE gRPC Server\n  participant P as Provider gRPC Client\n\n  P-&gt;&gt;C: UnregisterProvider(id, name, version)\n  note over C: Send shutdown signal to&lt;br /&gt;provider client routine\n  C-&gt;&gt;P: UnregisterReply(status)\n  note over P: Gracefully shutdown gRPC server</code></pre>"},{"location":"getting-started/providers/writing-a-provider/","title":"Writing a Provider","text":"<p>Coming soon</p>"},{"location":"references/","title":"References","text":"<p>This section of the documentation is intended to provide low-level reference for the inner workings of CBLE. For more general documentation, please refer to Getting Started.</p>"},{"location":"references/configuration/config-file/","title":"Config File","text":"<p>Coming soon</p>"},{"location":"references/permissions/permissions/","title":"Permissions","text":"<p>Coming soon</p>"}]}